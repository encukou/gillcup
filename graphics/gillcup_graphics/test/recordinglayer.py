from __future__ import division

"""Test helper

When a test module does:
from gillcup_graphics.test.recordinglayer import pytest_funcarg__layer
all test functions in it can use the ``layer`` funcarg, which records an image
of whatever is added to it, and compares it to a reference rendering in
gillcup_graphics/test/images/expected.
To account for different OpenGL implementations, 0.25% dissimilarity is
tolerated.

Images generated by the tests go in gillcup_graphics/test/images/expected,
along with "report" images that should hopefully make it clear what is
different.

This all is achieved by an EffectLayer subclass, ad invisible Window, pytest
funcargs, numpy matrix stacking and other such arcane hackery.

"""

import os

import pyglet.image
import numpy

from gillcup_graphics.mainwindow import Window
from gillcup_graphics.effectlayer import EffectLayer

expected_dir = os.path.join(os.path.dirname(__file__), 'images', 'expected')
actual_dir = os.path.join(os.path.dirname(__file__), 'images', 'result')
legend_path = os.path.join(os.path.dirname(__file__), 'images', 'legend.png')

image_width = 100
image_height = 100


class RecordingLayer(EffectLayer):
    def need_offscreen(self):
        return True

    def blit_buffer(self, framebuffer, **kwargs):
        self._last_data = framebuffer.get_image_data()
        super(RecordingLayer, self).blit_buffer(framebuffer=framebuffer,
            **kwargs)

    def get_image(self, width, height):
        window = Window(self, width=width, height=height, visible=False)
        window.manual_draw()
        return self._last_data


def get_data(image):
    array = numpy.array(
        [list(ord(n) for n in image.get_data(c, image.width)) for c in 'RGBA'],
        int)
    array.shape = 4, image.height, image.width
    return array


def try_unlink(path):
    try:
        os.unlink(path)
    except OSError:
        pass


def write_diff_report(result, expected, filename):
    # XXX: This is... ad-hoc?
    difference = abs(expected - result)
    zeros = numpy.zeros([4, image_width, image_height])
    alphadiff = expected.copy()
    alphadiff[3] = difference.sum(0) * 3 // 4 + 255 // 4
    zdiff = difference.copy()
    zdiff[3] = 255 - zdiff[3]
    diffdata = numpy.concatenate([result, expected, alphadiff, zdiff], 2)
    by_channel = None
    for current_channel in range(4):
        diff = difference.copy()
        diff[:4] = diff[current_channel]
        diff[3] = 255
        if by_channel is None:
            by_channel = diff
        else:
            by_channel = numpy.concatenate([by_channel, diff], 2)
    legend_image = pyglet.image.load(legend_path)
    diffdata = numpy.concatenate([
            by_channel,
            get_data(pyglet.image.load(legend_path)),
            diffdata
        ], 1)
    diffdata = diffdata.transpose([1, 2, 0]).clip(0, 255)
    diffdata = diffdata.reshape([diffdata.size])
    data_image = pyglet.image.ImageData(image_width * 4,
        image_height * 2 + legend_image.height,
        'RGBA', ''.join(chr(int(c)) for c in diffdata))
    data_image.save(filename)


def pytest_funcarg__layer(request):
    layer = RecordingLayer()

    @request.addfinalizer
    def finalizer():
        name = request.module.__name__
        if request.cls:
            name += '.' + request.cls.__name__
        name += '.' + request.function.__name__
        expected_filename = os.path.join(expected_dir, name + '.png')
        result_filename = os.path.join(actual_dir, name + '.png')
        difffilename = os.path.join(actual_dir, name + '.report.png')
        try_unlink(result_filename)
        try_unlink(difffilename)
        try:
            expected_image = pyglet.image.load(expected_filename)
            expected = get_data(expected_image)
        except:
            expected = None
        result_image = layer.get_image(image_width, image_height)
        result = get_data(result_image)
        if expected is not None and (expected == result).all():
            return True
        result_image.save(result_filename)
        if expected is None:
            raise AssertionError('Expected image not found.\n'
                'Expected:      %s\n'
                'Actual result: %s\n'
                '' % (expected_filename, result_filename))
        else:
            # Compare premultiplied images
            difference = abs(expected - result)
            for channel in range(3):
                difference[channel] *= difference[3] / 255
            maximum_dis = 255 * 4 * image_width * image_height
            dissimilarity = difference.sum() / maximum_dis
            threshold_dis = 0.0025
            write_diff_report(result, expected, difffilename)
            if dissimilarity < threshold_dis:
                print 'Pass'
            else:
                raise AssertionError('Images not same.\n'
                    'Dissimilarity: %.7s%% / %.7s%%\n'
                    'Expected:      %s\n'
                    'Actual result: %s\n'
                    'Report/deltas: %s\n'
                    '' % (
                        dissimilarity * 100,
                        threshold_dis * 100,
                        expected_filename, result_filename, difffilename))
    return layer
